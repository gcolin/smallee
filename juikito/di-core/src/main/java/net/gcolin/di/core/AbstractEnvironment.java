/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional information regarding
 * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License. You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package net.gcolin.di.core;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * A very simple environment for dependency injection.
 * 
 * @author GaÃ«l COLIN
 * @since 1.0
 *
 * @param <T> types of object stored in the environment
 */
public abstract class AbstractEnvironment<T> implements InjectService {

	/**
	 * Compare 2 annotations.
	 */
	public static final Comparator<Annotation> QUALIFIER_COMPARATOR = new Comparator<Annotation>() {

		@Override
		public int compare(Annotation o1, Annotation o2) {
			return o1.toString().compareTo(o2.toString());
		}
	};

	/**
	 * Check if an annotation is a qualifier.
	 * 
	 * @param annotationType Annotation type to check
	 * @return true if the annotation is a qualifier
	 */
	public abstract boolean isQualifier(Class<? extends Annotation> annotationType);

	private Map<String, T> binding;

	public AbstractEnvironment() {
		binding = new ConcurrentHashMap<>();
	}

	public AbstractEnvironment(Map<String, T> binding) {
		this.binding = new ConcurrentHashMap<>(binding);
	}

	/**
	 * Get the binding map. The binding map has string serialized key generated by
	 * the method createKey.
	 * 
	 * @return the binding map
	 */
	public Map<String, T> getBinding() {
		return binding;
	}

	/**
	 * Create a binding of a class to an object.
	 * 
	 * @param clazz The key class
	 * @param obj   The value
	 */
	public void bind(Class<?> clazz, T obj) {
		bind(clazz, obj, null);
	}

	/**
	 * Create a binding of a class to an object with qualifiers.
	 * 
	 * @param clazz      The key class
	 * @param obj        The value
	 * @param qualifiers The qualifiers
	 */
	public void bind(Class<?> clazz, T obj, Annotation[] qualifiers) {
		binding.put(createBindingKey(createKey(clazz, clazz, qualifiers)), obj);
	}

	@SuppressWarnings("unchecked")
	@Override
	public void bind(Object obj) {
		bind(obj.getClass(), (T) obj, findQualifiers(obj.getClass().getAnnotations()));
	}

	/**
	 * Check if a class is instanciable. The default implementation check if the
	 * class is not an interface and is not abstract.
	 * 
	 * @param clazz The class
	 * @return true if the the class is instanciable
	 */
	protected boolean isInstanciable(Class<?> clazz) {
		return !clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers());
	}

	/**
	 * Find a sorted list of qualifiers from an array of annotations.
	 * 
	 * @param annotations an array of annotations to check
	 * @return a sorted list of qualifiers
	 */
	public List<Annotation> findQualifiersList(Annotation[] annotations) {
		List<Annotation> list = new ArrayList<Annotation>();
		for (int i = 0, l = annotations.length; i < l; i++) {
			Annotation annotation = annotations[i];
			if (isQualifier(annotation.annotationType())) {
				list.add(annotation);
			}
		}
		Collections.sort(list, QUALIFIER_COMPARATOR);
		return list;
	}

	/**
	 * Find an array of qualifiers from an array of annotations.
	 * 
	 * @param annotations an array of annotations to check
	 * @return an array of qualifiers or null if there is no qualifier
	 */
	public Annotation[] findQualifiers(Annotation[] annotations) {
		List<Annotation> list = findQualifiersList(annotations);
		return list.toArray(new Annotation[list.size()]);
	}

	/**
	 * Resolve a binding.
	 * 
	 * @param key A binding key
	 * @return a binding value or null
	 */
	public T resolveBinding(Key key) {
		return binding.get(createBindingKey(key));
	}

	public String createBindingKey(Key key) {
		StringBuilder str = new StringBuilder(key.getType());
		if (key.getQualifiers() != null) {
			try {
				for (Annotation a : key.getQualifiers()) {
					str.append('@').append(a.annotationType().getSimpleName());
					for (Method m : a.annotationType().getMethods()) {
						if (m.getDeclaringClass() == a.annotationType()) {
							str.append(';').append(m.getName()).append('=').append(m.invoke(a));
						}
					}
				}
			} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
				throw new IllegalArgumentException(e);
			}
		}
		return str.toString();
	}

	/**
	 * Create a binding key.
	 * 
	 * @param clazz       A class
	 * @param genericType A genericType (can be null)
	 * @param qualifiers  A qualifier array (can be null)
	 * @return The binding key
	 */
	public Key createKey(Class<?> clazz, Type genericType, Annotation[] qualifiers) {
		Key key = new Key();
		if (genericType == null && clazz != null) {
			key.setType(clazz.getName());
		} else if (genericType != null) {
			String type = genericType.toString();
			if (type.startsWith("class ")) {
				key.setType(type.substring(6));
			} else if (type.startsWith("interface ")) {
				key.setType(type.substring(10));
			} else {
				key.setType(type);
			}
		}

		if (qualifiers == null) {
			key.setQualifiers(new Annotation[0]);
		} else {
			key.setQualifiers(qualifiers);
		}

		return key;
	}

	@Override
	public void add(Class<?>... classes) {
		for (Class<?> clazz : classes) {
			try {
				bind(clazz.getDeclaredConstructor().newInstance());
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | NoSuchMethodException | SecurityException ex) {
				throw new InjectException(ex);
			}
		}
	}

	@Override
	public void remove(Class<?>... classes) {
		for (Class<?> clazz : classes) {
			binding.remove(createBindingKey(createKey(clazz, clazz, findQualifiers(clazz.getAnnotations()))));
		}
	}

	@Override
	public void unbind(Object obj) {
		remove(obj.getClass());
	}

	@SuppressWarnings("unchecked")
	@Override
	public <X> Supplier<X> findSupplier(Class<X> clazz) {
		X obj = (X) resolveBinding(createKey(clazz, clazz, findQualifiers(clazz.getAnnotations())));
		if (obj != null) {
			return () -> obj;
		}
		return null;
	}

	@Override
	public Object find(String name) {
		return null;
	}

	@Override
	public boolean isMutable(Class<?> type) {
		return false;
	}

}
